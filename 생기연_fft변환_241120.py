# -*- coding: utf-8 -*-
"""생기연_FFT변환_241120.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d2bgX5pARaufMUpakxzggADkKr6KXudW

# **1. 데이터 불러오기**

# **2. 데이터 가시화**
"""

import pandas as pd
import numpy as np
from scipy.signal import correlate

# Load the CSV file to inspect its structure
file_path = '/content/drive/MyDrive/Colab Notebooks/project_PID/241113_바닥가진실험.csv'
df = pd.read_csv(file_path, header=None)

# Display the first few rows to understand the structure
df.head()

TEST_TYPE = ['GR', 'UP']
TEST_NO=[]
TEST_N = 10

# Extract headers for categorizing
test_labels = df.iloc[0]

# Starting from the fourth row, get the time series data
time_series_data = df.iloc[1:].reset_index(drop=True)

# Organize data into a dictionary with keys based on combined test, location, and data type labels
time_series_dict = {}
for col in range(1, df.shape[1]):
    if col%2==0:
        continue

    test_no1, test_type1 = test_labels[col].split('_')
    test_no2, test_type2 = test_labels[col+1].split('_')

    if test_no1 not in TEST_NO:
        TEST_NO.append(test_no1)
    if test_no2 not in TEST_NO:
        TEST_NO.append(test_no2)

    # Initialize nested dictionaries if not already present
    if test_no1 not in time_series_dict:
        time_series_dict[test_no1] = {}
    if test_no2 not in time_series_dict:
        time_series_dict[test_no2] = {}

    # Assign the time series values as a list to the dictionary
    time_series_dict[test_no1]["time"] = list(map(float, time_series_data[0].tolist()))#[4500:5000]
    time_series_dict[test_no1][test_type1] = list(map(float, time_series_data[col].tolist()))#[4500:5000]
    time_series_dict[test_no2][test_type2] = list(map(float, time_series_data[col + 1].tolist()))#[4500:5000]

"""## **개별 그래프 그리기**"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Plot each time series
sns.set(style="whitegrid")
plt.figure(figsize=(12, 6))

def plot_time_series_each(time_series_dict, tType, n=10):

    for test_no in TEST_NO[:n]:
        for test_type in tType:
            plt.figure(figsize=(10, 4))
            data_label = f'{test_no}_{test_type}'
            sns.lineplot(x=time_series_dict[test_no]['time'], y=time_series_dict[test_no][test_type], label=data_label)
            plt.xlabel("Time", fontsize=12)
            plt.ylabel("Magnitude", fontsize=12)
            plt.title(f"{data_label}", fontsize=14)
            plt.legend()
            plt.grid(True)
            plt.show()

plot_time_series_each(time_series_dict, TEST_TYPE, TEST_N)

"""## **한 그래프 2개 유형 함께**"""

def plot_time_series(data, ttype, n=10):
    for test_no in TEST_NO[:n]:
        plt.figure(figsize=(10, 4))
        for test_type in ttype:
            data_label = f'{test_no}_{test_type}'
            sns.lineplot(x=data[test_no]['time'], y=data[test_no][test_type], label=data_label
            )
        plt.xlabel("Time", fontsize=12)
        plt.ylabel("Data Value", fontsize=12)
        plt.title(f"Time vs Data Value for {data_label}", fontsize=14)
        plt.legend()
        plt.grid(True)
        plt.show()

plot_time_series(time_series_dict, TEST_TYPE, n=TEST_N)

"""# **3. 필터링 및 노이즈 제거**"""

from scipy.signal import butter, filtfilt

# Butterworth filter function
def butter_filter(data, cutoff, fs, order=4, filter_type='low'):
    """
    Apply Butterworth filter to the data.
    :param data: Input signal
    :param cutoff: Cutoff frequency (Hz)
    :param fs: Sampling frequency (Hz)
    :param order: Order of the filter
    :param filter_type: 'low' for low-pass, 'high' for high-pass
    :return: Filtered signal
    """
    nyquist = 0.5 * fs  # Nyquist frequency
    normal_cutoff = cutoff / nyquist  # Normalize cutoff frequency
    b, a = butter(order, normal_cutoff, btype=filter_type, analog=False)  # Filter coefficients
    filtered_data = filtfilt(b, a, data)  # Apply filter
    return filtered_data

# Define filter parameters
sampling_frequency = 100  # Sampling frequency in Hz (assumed)
low_cutoff = 10  # Low-pass filter cutoff frequency in Hz

# Apply filter to signals and plot
for test in TEST_NO[:TEST_N]:
    gr_signal = np.array(time_series_dict[test]["GR"])
    up_signal = np.array(time_series_dict[test]["UP"])

    # Apply low-pass filter
    filtered_gr = butter_filter(gr_signal, low_cutoff, sampling_frequency, filter_type='low')
    filtered_up = butter_filter(up_signal, low_cutoff, sampling_frequency, filter_type='low')

    time_series_dict[test]['GR_Filtered'] = filtered_gr.tolist()
    time_series_dict[test]['UP_Filtered'] = filtered_up.tolist()

    # Plot original and filtered signals
    plt.figure(figsize=(10, 8))

    # Original signals
    plt.subplot(2, 1, 1)
    plt.plot(gr_signal, label="GR (Original)", marker="o")
    plt.plot(up_signal, label="UP (Original)", marker="x")
    plt.title(f"Original Signals - {test}")
    plt.legend()
    plt.grid()

    # Filtered signals
    plt.subplot(2, 1, 2)
    plt.plot(filtered_gr, label="GR (Filtered)", marker="o")
    plt.plot(filtered_up, label="UP (Filtered)", marker="x")
    plt.title(f"Filtered Signals (Low-Pass) - {test}")
    plt.legend()
    plt.grid()

    plt.tight_layout()
    plt.show()

"""# **3. 신호 동기화 및 정렬**

## **교차 상관 분석 (Cross-Correlation)**
"""

# Function to compute time delay and synchronize signals
def synchronize_signals(signal1, signal2):
    # Compute cross-correlation
    corr = correlate(signal2, signal1, mode='full')
    lag = np.argmax(corr) - (len(signal1) - 1)  # Compute lag

    # Synchronize signals
    if lag < 0:
        synchronized_signal1 = signal1[lag:]  # Trim start of signal1
        synchronized_signal2 = signal2[:len(signal1) - lag]  # Trim end of signal2
    elif lag > 0:
        lag = abs(lag)
        synchronized_signal1 = signal1[:len(signal2) - lag]  # Trim end of signal1
        synchronized_signal2 = signal2[lag:]  # Trim start of signal2
    else:
        synchronized_signal1 = signal1
        synchronized_signal2 = signal2

    return synchronized_signal1, synchronized_signal2, lag

# Synchronize and plot for each test
for test in TEST_NO[:TEST_N]:
    gr_signal = np.array(time_series_dict[test]["GR_Filtered"])
    up_signal = np.array(time_series_dict[test]["UP_Filtered"])

    # Synchronize signals
    synced_gr, synced_up, lag = synchronize_signals(gr_signal, up_signal)

    time_series_dict[test]['GR_Sync'] = gr_signal.tolist()
    time_series_dict[test]['UP_Sync'] = up_signal.tolist()

    print(f"Test {test}: Time lag = {lag}")

    # Plot the original and synchronized signals
    plt.figure(figsize=(10, 8))

    # Original signals
    plt.subplot(2, 1, 1)
    plt.plot(gr_signal, label="GR (Original)", marker="o")
    plt.plot(up_signal, label="UP (Original)", marker="x")
    plt.title(f"Original Signals - {test}")
    plt.legend()
    plt.grid()

    # Synchronized signals
    plt.subplot(2, 1, 2)
    plt.plot(synced_gr, label="GR (Synchronized)", marker="o")
    plt.plot(synced_up, label="UP (Synchronized)", marker="x")
    plt.title(f"Synchronized Signals - {test}")
    plt.legend()
    plt.grid()

    plt.tight_layout()
    plt.show()

time_series_dict['TEST1'].keys()

"""# **3. FFT 변환**

## **퓨리에 변환**
"""

import numpy as np

def perform_fft(signal, sampling_frequency):
    """
    Perform FFT on a given signal and return frequency and magnitude spectrum.
    :param signal: Input time-series signal
    :param sampling_frequency: Sampling frequency (Hz)
    :return: Tuple (frequencies, magnitudes)
    """
    n = len(signal)  # Number of samples
    fft_result = np.fft.fft(signal)  # Perform FFT
    fft_magnitude = np.abs(fft_result)[:n // 2]  # Magnitude (first half)
    fft_frequency = np.fft.fftfreq(n, d=1/sampling_frequency)[:n // 2]  # Frequency (first half)
    return fft_frequency.tolist(), fft_magnitude.tolist()

sampling_frequency = 100  # Hz

# Apply FFT to all signals in the dictionary
for test_no in TEST_NO[:TEST_N]:

    test_data = time_series_dict[test_no]

    for key in ['GR_Sync', 'UP_Sync']:
        # Perform FFT
        frequencies, magnitudes = perform_fft(test_data[key], sampling_frequency)

        # Store FFT results in the dictionary
        test_data[f"{key}_FFT"] = {
            "frequencies": frequencies,
            "magnitudes": magnitudes
        }

time_series_dict['TEST1']['GR_Sync_FFT'].keys()

for test_no in TEST_NO[:TEST_N]:
    for test_type in ['GR_Sync_FFT', 'UP_Sync_FFT']:
        plt.figure(figsize=(10, 4))
        data_label = f'{test_no}_{test_type}'
        sns.lineplot(x=time_series_dict[test_no][test_type]['frequencies'], y=time_series_dict[test_no][test_type]['magnitudes']) #, label=data_label, linestyle='-')
        plt.xlabel("Frequency (Hz)", fontsize=12)
        plt.ylabel("Magnitude", fontsize=12)
        plt.title(f"FFT Spectrum for {data_label}", fontsize=14)
        #plt.legend()
        plt.grid(True)
        plt.show()

plot_time_series_each(time_series_dict, ['GR_Sync', 'UP_Sync'], TEST_N)

time_series_dict['TEST1'].keys()

"""# **신호비교: 유사성**"""

from scipy.spatial.distance import cosine

def Similarity(time_series_dict, n):

    similarity_results = {}

    for test_no in TEST_NO[:n]:
        similarity_results[test_no] = {}
        test_data = time_series_dict[test_no]

        # Extract signals for the two test types
        signal1, signal2 = np.array(test_data['GR']), np.array(test_data['UP'])
        signal1_f, signal2_f = np.array(test_data['GR_Filtered']), np.array(test_data['UP_Filtered'])
        signal1_s, signal2_s = np.array(test_data['GR_Sync']), np.array(test_data['UP_Sync'])
        signal1_t, signal2_t = np.array(test_data['GR_Sync_FFT']['frequencies']), np.array(test_data['UP_Sync_FFT']['frequencies'])

        # Compute Pearson correlation
        pearson_corr = np.corrcoef(signal1, signal2)[0, 1]
        pearson_corr_f = np.corrcoef(signal1_f, signal2_f)[0, 1]
        pearson_corr_s = np.corrcoef(signal1_s, signal2_s)[0, 1]
        pearson_corr_t = np.corrcoef(signal1_t, signal2_t)[0, 1]

        # Compute Cosine similarity
        #cosine_sim = 1 - cosine(signal1, signal2)

        # Store results
        similarity_results[test_no]["GR vs. UP"] = {
            "P. Cor_origial": pearson_corr,
            "P. Cor_filter": pearson_corr_f,
            "P. Cor_sync": pearson_corr_s,
            "P. Cor_sync_FFT": pearson_corr_t
        }

    # Convert similarity results to a DataFrame for table representation
    table_data = []
    for test_no, comparisons in similarity_results.items():
        for comparison, metrics in comparisons.items():
            row = {"Test Number": test_no, "Comparison": comparison}
            row.update(metrics)
            table_data.append(row)

    # Create a DataFrame
    df_similarity = pd.DataFrame(table_data)

    # Display the DataFrame
    return df_similarity

Similarity(time_series_dict, TEST_N)

"""# **감쇠효과 분석**"""

# Calculate amplitude reduction at key frequencies
key_freqs = list(range(16))  # Key frequencies to analyze

# Create a DataFrame to store the amplitude reduction
results = []

for test_no in TEST_NO:
    test_data = time_series_dict[test_no]

    freq_in = np.array(test_data['GR_Sync_FFT']['frequencies'])
    mag_in = np.array(test_data['GR_Sync_FFT']['magnitudes'])

    freq_out = np.array(test_data['UP_Sync_FFT']['frequencies'])
    mag_out = np.array(test_data['UP_Sync_FFT']['magnitudes'])

    amplitude_reduction = {
        f: (mag_out[np.argmin(np.abs(freq_out - f))] / mag_in[np.argmin(np.abs(freq_in - f))])
        for f in key_freqs
    }

    # Append results to the DataFrame
    results.append({"Test_No": test_no, **amplitude_reduction})

# Convert to DataFrame
df_results = pd.DataFrame(results)
df_results.set_index("Test_No", inplace=True)

# Display the DataFrame
df_results

import seaborn as sns
import matplotlib.pyplot as plt

# Check if there are any NaN values and fill them with 0 for visualization purposes
df_results_filled = df_results.fillna(0)

# Create the heatmap
plt.figure(figsize=(12, 8))
sns.heatmap(
    df_results_filled,
    annot=True,           # Display the values in the heatmap
    cmap="coolwarm",      # Choose a color map
    cbar_kws={"label": "Amplitude Reduction Ratio"},  # Color bar label
    linewidths=0.5        # Add grid lines
)

# Add title and labels
plt.title("Amplitude Reduction Heatmap", fontsize=16)
plt.xlabel("Frequency (Hz)", fontsize=12)
plt.ylabel("Test Number", fontsize=12)

# Show the heatmap
plt.show()

df_results

# Example plotting for a single test case
test_no = TEST_NO[0]
test_data = time_series_dict[test_no]
freq_in = np.array(test_data['GR_Sync_FFT']['frequencies'])
mag_in = np.array(test_data['GR_Sync_FFT']['magnitudes'])
freq_out = np.array(test_data['UP_Sync_FFT']['frequencies'])
mag_out = np.array(test_data['UP_Sync_FFT']['magnitudes'])

plt.figure(figsize=(10, 6))
plt.plot(freq_in, mag_in, label="Input Signal (Gained)", color="blue")
plt.plot(freq_out, mag_out, label="Output Signal (Damped)", color="orange")
plt.title(f"Frequency Spectrum Comparison for {test_no}")
plt.xlabel("Frequency (Hz)")
plt.ylabel("Magnitude")
plt.legend()
plt.grid()
plt.show()

